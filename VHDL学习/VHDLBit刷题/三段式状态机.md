# 三段式状态机



代码示例：

```verilog
module sequence_detector_101 (
    input       clk,        // 时钟信号
    input       rst_n,      // 复位信号（低电平有效）
    input       data_in,    // 数据输入
    output reg  detect_out  // 检测结果输出
);

    // 1. 定义状态空间 (One-hot 编码或二进制编码均可，这里用二进制)
    localparam IDLE = 2'b00; // 初始状态
    localparam S1   = 2'b01; // 检测到第一个 '1'
    localparam S2   = 2'b10; // 检测到 '10'
    // 注意：通常对于重叠检测，检测到101后会直接跳回某状态，不需要专门维持一个S3状态太久，
    // 但为了演示输出逻辑，我们这里设定逻辑：当状态机判断下一步是满足条件时，输出高。

    // 定义当前状态和次态寄存器
    reg [1:0] current_state;
    reg [1:0] next_state;

    // ============================================================
    // 第一段：时序逻辑 (Sequential Logic)
    // 描述：状态寄存器的更新。
    // 作用：将 next_state 传递给 current_state。
    // ============================================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= IDLE;
        else
            current_state <= next_state;
    end

    // ============================================================
    // 第二段：组合逻辑 (Combinational Logic)
    // 描述：计算下一个状态 (Next State Logic)。
    // 作用：根据 current_state 和输入 data_in 决定 next_state。
    // ============================================================
    always @(*) begin
        // 初始化 next_state，防止产生 Latch
        next_state = current_state; 
        
        case (current_state)
            IDLE: begin
                if (data_in == 1'b1)
                    next_state = S1;
                else
                    next_state = IDLE;
            end

            S1: begin // 已有一个 '1'
                if (data_in == 1'b0)
                    next_state = S2; // 变为 '10'
                else
                    next_state = S1; // 还是 '1' (11 -> 这里的1算新的开始)
            end

            S2: begin // 已有 '10'
                if (data_in == 1'b1)
                    next_state = S1; // 变为 '101' (成功检测)，下一拍跳回 S1 (因为101的最后1个1可以作为下一次101的开头)
                else
                    next_state = IDLE; // 变为 '100' -> 失败，重来
            end

            default: next_state = IDLE;
        endcase
    end

    // ============================================================
    // 第三段：时序逻辑 (Sequential Logic) - 推荐做法
    // 描述：输出逻辑 (Output Logic)。
    // 作用：根据 next_state (或者 current_state) 产生输出。
    // ============================================================
    // 注意：这里我们使用时序逻辑输出，这被称为 "Registered Output" (寄存器输出)。
    // 它可以让输出信号非常干净（没有组合逻辑毛刺），有利于时序收敛。
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            detect_out <= 1'b0;
        end
        else begin
            // 这里利用 next_state 做超前判断，
            // 使得输出 detect_out 和状态跳转同步出现，不会滞后一个周期。
            // 逻辑：如果当前状态是 S2 且 输入是 1，说明即将构成 101。
            if (current_state == S2 && data_in == 1'b1)
                detect_out <= 1'b1;
            else
                detect_out <= 1'b0;
        end
    end

endmodule
```

### 2. 代码详解：为什么要分三段？





#### 第一段：状态跳转（Synchronous）



- **代码特征：** `always @(posedge clk ...)`，内部赋值 `current_state <= next_state`。
- **功能：** 这是状态机的“心跳”。它负责在时钟上升沿到来时，把计算好的“未来”变成“现在”。
- **为什么：** 必须是时序逻辑，因为状态机是有记忆的系统。



#### 第二段：次态逻辑（Combinational）



- **代码特征：** `always @(*)`，内部使用 `case(current_state)` 和 `if-else`，赋值使用阻塞赋值 `=`。
- **功能：** 这是状态机的“大脑”。它纯粹通过组合逻辑计算：基于**我现在在哪**以及**输入是什么**，来决定**我下一步去哪**。
- **关键点：**
  - 一定要写 `default`，防止状态跑飞。
  - 最好在 case 前给 `next_state` 赋初值（通常是 `next_state = current_state` 或 `IDLE`），防止产生 **Latch（锁存器）**。



#### 第三段：输出逻辑（Synchronous / Registered）



- **代码特征：** `always @(posedge clk ...)`。
- **功能：** 这是状态机的“手”。决定对外输出什么信号。
- **核心优势（敲黑板）：**
  - **防毛刺：** 如果使用组合逻辑（`assign` 或 `always @(*)`）直接产生输出，当状态在切换瞬间，或者输入信号有抖动时，输出信号可能会出现瞬间的尖峰（Glitch）。这对于高速电路是致命的。
  - **时序友好：** 使用时序逻辑输出（如代码所示），输出信号直接来自触发器（Flip-Flop），也就是 **Registered Output**。这意味着输出信号的 `Tco`（Clock to Output）时间非常短且确定，非常利于后端布局布线和时序收敛。



### 3. 常见疑问解答



**Q: 为什么我在书上看到的第三段是组合逻辑？**

> **A:** 传统的教科书（或者二段式写法）常把第三段写成组合逻辑（`assign out = (state == S2);`）。这样做的好处是输出**立即**响应，没有延迟。坏处是容易有毛刺。 在现代 FPGA/ASIC 设计中，**推荐用代码中的时序逻辑写第三段**。虽然输出会比输入晚一拍（或者像我在代码里那样用 `next_state` 逻辑做预判来对齐），但信号质量高得多。

**Q: 代码中第三段为什么判断条件比较复杂？**

> **A:** 这是一个高级技巧。如果你写 `case(current_state) ... S2: out <= 1;`，那么输出会比状态 S2 滞后一个周期（因为是时序逻辑）。 为了让输出在检测到 `101` 的**当且仅当**那个周期变高，我在第三段里实际上复用了第二段的判断逻辑（`current_state == S2 && data_in == 1`）。这是一种在保持寄存器输出优势的同时，修正时序滞后的常用手法。



### 总结



三段式状态机的核心口诀：

1. **第一段（时序）：** 此时此刻是谁（Current <= Next）。
2. **第二段（组合）：** 下一步去哪儿（Case Current, calculate Next）。
3. **第三段（时序）：** 决定对外说什么（根据逻辑输出，并在时钟沿打拍）。