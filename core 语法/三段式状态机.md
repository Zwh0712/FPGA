# 通用的骨架，任何状态机都可以套用这个模版

```verilog
module fsm_template (
    input  wire clk,        // 时钟
    input  wire rst_n,      // 复位 (低电平有效)
    input  wire in_signal,  // 输入信号
    output reg  out_signal  // 输出信号
);

    // 1. 定义状态 (使用 parameter 或 localparam)
    // 推荐用独热码 (One-Hot) 编码，速度快，适合 FPGA
    localparam IDLE  = 3'b001;
    localparam WORK  = 3'b010;
    localparam DONE  = 3'b100;

    // 2. 定义状态寄存器
    reg [2:0] current_state;
    reg [2:0] next_state;

    // ======================================================
    // 第一段：时序逻辑 (Sequential Logic)
    // 作用：状态寄存器更新。也就是“我在哪”的更新。
    // 特点：同步复位或异步复位，只要时钟来，就把 next 给 current。
    // ======================================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            current_state <= IDLE; // 复位回初始状态
        else
            current_state <= next_state; // 切换到下一状态
    end

    // ======================================================
    // 第二段：组合逻辑 (Combinational Logic)
    // 作用：计算下一状态。也就是“我要去哪”。
    // 特点：使用阻塞赋值 (=)，必须包含 default 防止锁存器 (Latch)。
    // ======================================================
    always @(*) begin
        next_state = current_state; // 默认保持原状态 (这是一个好习惯)
        
        case (current_state)
            IDLE: begin
                if (in_signal) next_state = WORK;
                else           next_state = IDLE;
            end

            WORK: begin
                // 具体的跳转逻辑...
                next_state = DONE;
            end

            DONE: begin
                next_state = IDLE;
            end

            default: next_state = IDLE; // 必须写！防止跑飞
        endcase
    end

    // ======================================================
    // 第三段：时序逻辑 (Sequential Logic) - 这里的写法是三段式的精髓
    // 作用：输出逻辑。也就是“我要做什么”。
    // 特点：使用 next_state 进行判断，产生寄存器输出 (无毛刺)。
    // ======================================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            out_signal <= 1'b0; // 复位输出
        end
        else begin
            // 注意：这里根据 next_state 判断，可以提前一拍让输出对齐状态
            // 也可以根据 current_state 判断，输出会比状态晚一拍
            // 推荐：大多数情况配合 next_state 使用
            case (next_state)
                IDLE:    out_signal <= 1'b0;
                WORK:    out_signal <= 1'b1; // 举例：WORK 状态输出高
                DONE:    out_signal <= 1'b0;
                default: out_signal <= 1'b0;
            endcase
        end
    end

endmodule
```

### 实战演练：设计一个“序列检测器”

**任务**：检测输入流，当连续检测到 `1` -> `0` -> `1` 时，输出一个高电平脉冲。

**设计步骤**：

1. **状态定义**：

   - `S_IDLE`: 初始状态。

   - `S_1`: 已经检测到了 `1`。

   - `S_10`: 已经检测到了 `10`。

   - `S_101`: 已经检测到了 `101` (匹配成功)

     ```verilog
     module seq_det_101 (
         input wire clk,
         input wire rst_n,
         input wire data_in,
         output reg match_flag // 检测成功标志
     );
     
         // 独热码定义状态
         localparam S_IDLE = 4'b0001;
         localparam S_1    = 4'b0010;
         localparam S_10   = 4'b0100;
         localparam S_101  = 4'b1000;
     
         reg [3:0] current_state, next_state;
     
         // --- 第一段：状态跳转 ---
         always @(posedge clk or negedge rst_n) begin
             if (!rst_n)
                 current_state <= S_IDLE;
             else
                 current_state <= next_state;
         end
     
         // --- 第二段：判断下一状态 ---
         always @(*) begin
             next_state = current_state; // 默认保持
             case (current_state)
                 S_IDLE: begin
                     if (data_in == 1) next_state = S_1;
                     else              next_state = S_IDLE;
                 end
                 S_1: begin
                     if (data_in == 0) next_state = S_10; // 来了0，变成10
                     else              next_state = S_1;  // 来了1，还是1，保持在S_1
                 end
                 S_10: begin
                     if (data_in == 1) next_state = S_101; // 来了1，变成101，成功！
                     else              next_state = S_IDLE; // 来了0，变成100，失败，重来
                 end
                 S_101: begin
                     // 这里处理重叠检测，如果 101 之后来了 0，可能变成 10 (属于下一个101的开头)
                     if (data_in == 1) next_state = S_1;
                     else              next_state = S_10; 
                 end
                 default: next_state = S_IDLE;
             endcase
         end
     
         // --- 第三段：输出逻辑 ---
         always @(posedge clk or negedge rst_n) begin
             if (!rst_n)
                 match_flag <= 0;
             else begin
                 // 方法A (常用)：基于 next_state 提前判断，这样输出和状态跳转同步
                 // 只要 next_state 是 S_101，说明这一拍算完就是成功了，立刻输出高
                 if (next_state == S_101)
                     match_flag <= 1;
                 else
                     match_flag <= 0;
             end
         end
     
     endmodule
     ```

     ### 避坑指南 (初学者必看)

     1. **必须写 Default**：在第二段 `case` 语句中，永远加上 `default: next_state = IDLE;`。这是为了防止状态机如果不小心跑到了未定义的状态（比如受到辐射干扰），能够自动恢复，而不是死机。
     2. **第二段用阻塞赋值 (=)**：因为是组合逻辑。
     3. **第一、三段用非阻塞赋值 (<=)**：因为是时序逻辑。
     4. **第三段用 `next_state` 还是 `current_state`？**
        - 如果你用 `case(current_state)` 来决定输出，输出信号会比状态跳转**晚一个时钟周期**。
        - 如果你用 `case(next_state)` 来决定输出（如上面的例子），输出信号会跟状态跳转**完全同步**。
        - *建议：初学时优先使用 `next_state` 来做判断，逻辑直观。*